<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI助手 - ReSpider Mod Wiki</title>
    <link rel="icon" href="ico/title-logo.ico">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/wiki-ai.css">
</head>
<body>
    <div class="wiki-bg">
        <div class="wiki-header">
            <div class="wiki-header-title">
                <a href="index.html">ReSpider Mod</a>
            </div>
            <div class="wiki-header-logo">
                <img src="img/wiki-logo.png" alt="logo" width="128px">
            </div>
        </div>
        
        <div class="wiki-nav"> 
            <a href="index.html">首页</a>
            <a href="character.html">人物</a>
            <a href="skill.html">技能</a>
            <a href="wiki-ai.html" class="active">AI助手</a>
        </div>
        
        <div class="wiki-content">
            <div id="ai-assistant">
                <!-- 聊天消息区域 -->
                <div class="chat-messages" ref="messagesContainer">
                    <!-- 遍历 messages 数组，动态生成消息 -->
                    <div v-for="(msg, index) in messages" :key="msg.id" :class="['message', msg.role === 'user' ? 'user-message' : 'ai-message']">
                        <div class="message-header">
                            <strong>{{ msg.role === 'user' ? '你' : 'Spider AI' }}</strong>
                            <span class="time">{{ formatTime(msg.timestamp) }}</span>
                        </div>
                        <div class="message-content">
                            <!-- 使用 v-html 或 {{ }} 渲染内容，这里用文本渲染确保安全 -->
                            {{ msg.content }}
                        </div>
                    </div>
                </div>
                <!-- 新增：输出模式切换区域 -->
                <div class="output-mode">
                    <label>输出模式：</label>
                    <button @click="toggleOutputMode" :class="{ 'active': !useStream }">
                        {{ useStream ? '流式输出' : '非流式输出' }}
                    </button>
                    <span class="mode-hint">(当前：{{ useStream ? '流式' : '非流式' }})</span>
                </div>
                <!-- 新增：模型选择区域 -->
                <div class="model-selector">
                    <label>选择AI模型：</label>
                    <select v-model="selectedModel">
                        <option value="glm-4">智谱AI (GLM-4)</option>
                        <option value="qwen-turbo">通义千问 (Turbo)</option>
                        <!-- 未来可以轻松添加更多选项，例如： -->
                        <!-- <option value="moonshot">Kimi (Moonshot)</option> -->
                    </select>
                    <span class="model-hint">当前：{{ getModelName(selectedModel) }}</span>
                </div>
                <!-- 输入区域 -->
                <div class="input-area">
                    <textarea 
                        v-model="userInput" 
                        placeholder="输入您的问题..."
                        @keydown.enter.prevent="sendMessage"
                        @keydown.shift.enter.exact="handleShiftEnter"
                        rows="3"
                    ></textarea>
                    <button @click="sendMessage" :disabled="isLoading">
                        {{ isLoading ? '思考中...' : '发送' }}
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { createApp, ref, onMounted, onUnmounted, nextTick, watch } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";

        createApp({
            setup() {
                // 响应式数据
                const useStream = ref(true);
                const userInput = ref('');
                const messages = ref([]);
                const isLoading = ref(false);
                const messagesContainer = ref(null); // DOM 引用
                let abortController = null; // 用于取消请求
                const selectedModel = ref('glm-4'); // 默认模型

                const getModelName = (modelValue) => {
                const map = { 'glm-4': '智谱GLM-4', 'qwen-turbo': '通义千问Turbo' };
                return map[modelValue] || modelValue;
                };

                onMounted(() => {
                    messages.value.push({
                        id: 0,
                        role: 'assistant',
                        content: '你好！我是Spider AI，有什么可以帮助您的吗？',
                        timestamp: new Date() // 直接存储Date对象
                    });
                });

                // 组件卸载时清理请求
                onUnmounted(() => {
                    if (abortController) {
                        abortController.abort();
                    }
                });

                const toggleOutputMode = () => {
                    useStream.value = !useStream.value;
                    console.log(`已切换到 ${useStream.value ? '流式' : '非流式'} 输出模式`);
                };

                // 简化时间格式化
                const formatTime = (timestamp) => {
                    if (!timestamp) return '';
                    const date = new Date(timestamp);
                    // 如果日期无效，返回空字符串
                    if (isNaN(date.getTime())) return '';
                    return date.toLocaleTimeString('zh-CN', { hour12: false });
                };

                // 发送消息（移除了有问题的防抖逻辑）
                const sendMessage = async () => {
                    if (!userInput.value.trim() || isLoading.value) return;

                    const userMessage = userInput.value.trim();
                    messages.value.push({
                        id: Date.now(),
                        role: 'user',
                        content: userMessage,
                        timestamp: new Date()
                    });

                    userInput.value = '';
                    isLoading.value = true;

                    try {
                        if (useStream.value) {
                            await sendNormalRequest(userMessage, selectedModel.value);
                        } else {
                            await sendNonStreamRequest(userMessage, selectedModel.value);
                        }
                     } catch (error) {
                        // 忽略因取消请求而产生的 AbortError
                        if (error.name !== 'AbortError') {
                            console.error('请求失败:', error);
                            messages.value.push({
                                id: Date.now() + 1,
                                role: 'assistant',
                                content: `抱歉，出错了：${error.message}`,
                                timestamp: new Date()
                            });
                        }
                    } finally {
                        isLoading.value = false;
                    }
                };

                const sendNonStreamRequest = async (userMessage) => {
                    abortController = new AbortController();
                    const aiMessageIndex = messages.value.length;

                    messages.value.push({
                        id: Date.now(),
                        role: 'assistant',
                        content: '正在思考...',
                        timestamp: new Date()
                    });

                    try {
                        const proxyUrl = 'https://respider-wiki.vercel.app/api/chat';
                        const response = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                messages: messages.value.slice(0, -1).map(msg => ({
                                    role: msg.role,
                                    content: msg.content
                                })),
                                stream: false
                            }),
                            signal: abortController.signal
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`API请求失败：${response.status} - ${errorText}`);
                        }

                        const data = await response.json();
                        const fullContent = data.choices[0]?.message?.content || '（未收到内容）';
                        messages.value[aiMessageIndex].content = fullContent;

                    } catch (error) {
                        if (error.name === 'AbortError') {
                            // 请求被取消，移除消息
                            messages.value.splice(aiMessageIndex, 1);
                            throw error;
                        } else {
                            // 其他错误，在消息中显示
                            console.error('非流式请求失败:', error);
                            messages.value[aiMessageIndex].content = `请求出错：${error.message}`;
                        }
                    } finally {
                        if (messages.value[aiMessageIndex]) {
                            messages.value[aiMessageIndex].timestamp = new Date();
                        }
                        abortController = null;
                    }
                };

                // 流式请求函数
                const sendNormalRequest = async (userMessage) => {
                    // 为本次请求创建新的控制器
                    abortController = new AbortController();
                    const aiMessageIndex = messages.value.length;

                    messages.value.push({
                        id: Date.now(),
                        role: 'assistant',
                        content: '', // 初始为空
                        timestamp: new Date()
                    });

                    try {
                        const proxyUrl = 'https://respider-wiki.vercel.app/api/chat';
                        const response = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                messages: messages.value.slice(0, -1).map(msg => ({
                                    role: msg.role,
                                    content: msg.content
                                })),
                                stream: true
                            }),
                            signal: abortController.signal
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`API请求失败：${response.status} - ${errorText}`);
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder('utf-8');
                        let accumulatedText = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value, { stream: true });
                            const lines = chunk.split('\n').filter(line => line.trim() !== '');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') continue;

                                    try {
                                        const parsed = JSON.parse(data);
                                        const contentDelta = parsed.choices[0]?.delta?.content || '';
                                        if (contentDelta) {
                                            accumulatedText += contentDelta;
                                            // 响应式更新内容
                                            messages.value[aiMessageIndex].content = accumulatedText;
                                        }
                                    } catch (e) {
                                        console.warn('解析流数据失败:', e, '原始数据:', data);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log('请求已被用户取消');
                            // 移除因取消而产生的空AI消息
                            messages.value.splice(aiMessageIndex, 1);
                            throw error; // 重新抛出，让 sendMessage 中的错误处理忽略它
                        } else {
                            console.error('流式请求过程中发生错误:', error);
                            // 更新为错误信息
                            messages.value[aiMessageIndex].content = `请求出错：${error.message}`;
                        }
                    } finally {
                        // 确保最终时间戳正确（仅当消息未被取消时）
                        if (messages.value[aiMessageIndex]) {
                            messages.value[aiMessageIndex].timestamp = new Date();
                        }
                        // 本次请求结束，清理控制器
                        abortController = null;
                    }
                };

                // 简化后的Shift+Enter处理：阻止默认换行，改为发送
                const handleShiftEnter = (event) => {

                };

                // 滚动到底部
                const scrollToBottom = async () => {
                    await nextTick();
                    if (messagesContainer.value) {
                        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
                    }
                };

                // 监听消息变化并自动滚动
                watch(messages, scrollToBottom, { deep: true });

                return {
                    userInput,
                    messages,
                    isLoading,
                    messagesContainer,
                    formatTime,
                    sendMessage,
                    handleShiftEnter,
                    scrollToBottom,
                    useStream,
                    toggleOutputMode,
                    selectedModel, 
                    getModelName,  
                    sendNormalRequest,
                    sendNonStreamRequest
                };
            }
        }).mount("#ai-assistant");
    </script>
</body>
</html>